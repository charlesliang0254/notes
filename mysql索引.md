

## 索引

索引：排好序的快速查找数据结构。

- 索引的作用：1、排序 order by；2、快速查找 where
- 索引本身也很大，往往以索引文件的形式存放在磁盘上
- 优势：提升查询性能，降低IO成本；降低排序成本，降低CPU成本
- 劣势：占据存储空间，额外维护索引

引擎：

- 引擎不是针对数据库而言的，而针对数据库表而言的
- mysql支持MyISAM引擎和InnoDB引擎：
  - 其中MyISAM引擎索引和数据是分开存放的，.frm存放表结构，.MYD存放数据，.MYI存放索引
  - InnoDB引擎索引和数据存放在一起，.frm存放表结构，.ibd存放索引和数据，InnoDB引擎表数据文件本身就是按照B+树组织的一个索引结构文件。InnoDB索引是聚集索引，索引结构的叶子节点中包含了全部的数据。
- 主键索引与二级索引：主键索引是将索引和数据本身存放在一起，非主键索引是二级索引，将索引和主键存放在一起。主键索引的效率高于非主键索引，非主键索引需要回表查询主键索引。
- InnoDB引擎数据表建议设置主键，推荐自增的整型主键。
  - 如果没有设置主键，会找到第一个不含NULL的唯一索引列作为主键列。如果没有这样的列，就会使用6bytes的行号生成一个聚集索引作为主键，自增，可以使用select _rowid from 表名来查询
  - 推荐自增整型主键，不推荐使用UUID作为主键。主键列的长度越小，每个节点能够存放的索引值就更多，B+树的高度就更小，查询效率更高。UUID长度较长，每个节点存放的索引值较少，查询效率低；并且UUID的值不具有连续性，会导致B+树频繁出现节点的分裂。

索引使用的数据结构：二叉树、红黑树、Hash表、B树、B+树

- 二叉树：不能够平衡树的高度

- 红黑树：每个节点存放的数据量比较少，树的高度比较大，会导致IO次数显著增加
- B树：每个节点能够存放更多的索引，数据同时存放在叶子节点和内部节点。查询效率有所提升，但是对于区间查询的支持明显不足
- B+树：在B树的基础上，内部节点只存放索引，叶子节点存放全部的数据，使用指针将所有叶子节点串联成双向循环链表。内部节点只存放索引，每个节点能够存放更多的索引，从而降低树的高度。
- Hash表：将索引值的hash值直接映射为存放数据的地址，能够显著降低查询的复杂度，但是仅能支持=和IN查询，不支持区间查询；存在hash冲突的情况，需要特殊处理。

索引的分类：

- 单值索引：包含单个列的索引，一个表可以有多个索引，单个表索引数不建议超过5个
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引（联合索引）：一个索引包含多个列

索引的结构：B+树索引、Hash索引、full-text全文索引、R-tree索引

哪些情况下需要创建索引：

- 主键自动建立唯一索引
- 频繁查询的字段应该建立索引
- 查询中与其他表关联的字段创建索引
- 频繁更新的字段不适合创建索引
- where条件使用的字段创建索引
- 单键/组合索引的选择问题
- 排序字段考虑建立索引提升排序速度
- 查询中统计或分组的字段可以建立索引

哪些情况下不需要创建索引：

- 表记录太少
- 经常增删改的表
- 如果某个数据列包含许多重复的内容，建立索引意义不大。不重复且分布均匀的列更适合建立索引

explain：查询执行计划

- 执行计划包含的信息：

  ```txt
  id  select_type  table  type  possible_keys  key  key_length  ref  rows  extra
  ```

- id: select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序

  - id相同，执行顺序从上至下
  - id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  - id相同和不同的情况同时存在：id如果相同，可以认为是一组，从上往下执行；在所有组中，id值越大，优先级越高，越先执行

- select_type：查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂查询

  - 取值：simple、primary、subquery、derived、union、union result
  - simple：简单select查询，查询中不包含子查询或者union
  - primary：查询中如果包含任何复杂的子部分，最外层的查询类型标记为primary
  - subquery：在select或者where中包含了子查询
  - derived：在from列表中包含的子查询被标记为derived，mysql会递归执行这些子查询，并把结果放在临时表中
  - union：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived
  - union result：从union表获取结果的select

- table：显示这一行数据是关于那张表的

- type：访问类型

  - 访问类型排序：

    ```
    常见：system > const > eq_ref > ref > range > index > ALL
    完整版：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
    一般来说，需要保证查询至少达到range级别，最好能达到ref
    ```

  - system：表只有一行记录，是const类型的特例

  - const：按主键列或唯一索引列查询唯一的记录

  - eq_ref：按关联表的主键或唯一索引列1对1联表查询

  - ref：按关联表的索引列1对多联表查询

  - range：按照索引列范围查询（between、<、>、in），key列显示了使用哪个索引

  - index：扫描整个索引树

  - ALL：全表扫描

- possible_keys：显示可能应用在这张表上的索引，一个或者多个；查询涉及到的字段上如果存在索引，则该索引将被列出，但不一定被查询实际使用

- key：实际使用的索引，如果为NULL，则表示没有使用索引；查询中如果使用了覆盖索引，则该索引仅出现在key列表中

  > 覆盖索引：索引的字段能够完全覆盖查询的字段，这时只需要读取索引而不需要读取数据列

- key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精度的前提下，长度越短越好；key_len显示索引字段的最大可能长度，并且实际使用长度，即key_len是通过表定义计算得到的，而不是通过检索表的内容得到的

联合索引：

- 联合索引是按照索引列从左到右的顺序排序的，只有符合联合索引最左前缀的列才能走联合索引。
- 原理：使用B+树索引时，先按第一列排序，然后在按第二列排序，以此类推。如果要跳过第一列直接查询第二列，就需要针对第一列的值划分的每一个区间中进行查询，查询效率相对于不走索引，并没有明显的提升





## 



